上面两个test 得到的结论为：
1. 并发需要请求一个对象时，能在实例化之后很快处理的，或者对象构造过程中可能对内存有负面影响的，用Pool设计模式会更好
2. 还有可能从Pool中取的的东西的效率比重新构建还慢，那么就没必要使用Pool

如果使用了Pool，需要注意以下几点：
1. 当实例化sync.Pool的时候 调用的New方法创建一个成员变量，在调用时是线程安全的。
2. 当收到一个来自Get的实例时，不要对所接受到的对象的状态作出任何的假设。
3. 当用完一个从Pool中取得的对象后，需要调用Put，否则这个对象将不会被复用。通常情况下 是通过defer完成的
4. Pool内的分布必须大致均匀

自己的一部分总结：
1？ Pool类似于一个快速缓存，线程安全，可针对程序本身进行资源的申请(Get/New)和释放(Put)